---
const PIGEON_SRC = "/images/annimation/pigeon.png";
const CAT_SRC    = "/images/annimation/chat.png";
---

<style is:inline>
  /* Desktop only */
  @media (max-width:1023px){
    #pigeon-wrap, #pigeon-cat { display:none !important; }
  }

  /* PIGEON posé — position + TAILLE */
  #pigeon-wrap{
    position: absolute;
    left: calc(50% + 50px);
    bottom: 2.8rem;
    transform: translateX(-50%);
    z-index: 5;                 /* crée un contexte d’empilement local */
    pointer-events: auto;
    width: max-content;         /* évite l’écrasement */
  }

  :root { --pigeon-size: 70px; }     /* taille globale du pigeon */

  #pigeon{
    width: var(--pigeon-size) !important;
    height: auto !important;
    aspect-ratio: 1 / 1;        /* réserve la hauteur avant chargement (fix FF 1er hover) */
    max-width: none !important;
    max-height: none !important;
    display: block;
    cursor: pointer;
    position: relative;
    left: 50%;
    transform: translateX(-50%);
    filter: drop-shadow(0 2px 0 rgba(0,0,0,.2));
    z-index: 1;                 /* en dessous de la bulle */
  }

  /* BULLE */
  #pigeon-bubble{
    position: absolute;
    left: 50%;
    bottom: 100%;
    transform: translate(-50%,-8px);
    background: #fff; color:#000;
    border: 1px solid #000; border-radius: .5rem;
    padding: .4rem .6rem;
    font-size: .95rem;
    line-height: 1.15;
    text-align: center;
    white-space: nowrap;             /* 1 ligne par défaut */
    display: inline-block;
    max-width: none;
    opacity: 0;
    transition: opacity .18s ease, transform .18s ease;
    pointer-events: none;
    box-shadow: 0 2px 0 rgba(0,0,0,.2);
    z-index: 2;                      /* au-dessus du pigeon (fix empilement FF) */
    will-change: opacity, transform; /* rend l’apparition plus fiable */
  }

  /* pas de petite pointe */
  #pigeon-bubble::before,
  #pigeon-bubble::after{ display: none !important; content: none !important; }

  /* visible au hover (sauf si fade/lock) */
  #pigeon-wrap:hover #pigeon-bubble{
    opacity:1; transform:translate(-50%,-12px);
  }

  /* mode message bloquant → DEUX LIGNES EXACTES (respect \n, pas de wrap auto) */
  #pigeon-wrap.msg-lock #pigeon-bubble{
    opacity:1 !important;
    transform:translate(-50%,-12px) !important;
    white-space: pre; /* respecte \n, pas d'autowrap */
  }

  /* état de disparition en fondu (général) */
  #pigeon-bubble.bubble--fade{
    opacity: 0 !important;
    transform: translate(-50%,-6px);
    transition: opacity .35s ease, transform .35s ease;
  }

  /* >>> gagne la guerre de spécificité quand msg-lock est actif */
  #pigeon-wrap.msg-lock #pigeon-bubble.bubble--fade{
    opacity: 0 !important;
    transform: translate(-50%,-6px) !important;
  }

  /* >>> neutralise aussi le :hover pendant le fade */
  #pigeon-wrap:hover #pigeon-bubble.bubble--fade{
    opacity: 0 !important;
    transform: translate(-50%,-6px) !important;
  }

  /* CHAT */
  #pigeon-cat{
    position: fixed;
    right: -140px;
    width: 80px;
    z-index: 999;
    pointer-events: none;
    transform: translateX(0) scale(1);
    transition: transform .3s ease;
    filter: drop-shadow(0 4px 0 rgba(0,0,0,.2));
  }
  #pigeon-cat.cat--in { transform: translateX(-130px) scale(.85); }
  #pigeon-cat.cat--out{ transform: translateX(0)      scale(1);   }
</style>

<!-- Wrap pigeon + bulle -->
<div id="pigeon-wrap" aria-hidden="true">
  <div id="pigeon-bubble">envoyer un pigeon voyageur</div>
  <img id="pigeon" src={PIGEON_SRC} alt="" />
</div>

<!-- Chat à droite -->
<img id="pigeon-cat" src={CAT_SRC} alt="" />

<script is:inline>
(() => {
  const wrap   = document.getElementById('pigeon-wrap');
  const bubble = document.getElementById('pigeon-bubble');
  const pigeon = document.getElementById('pigeon');
  const cat    = document.getElementById('pigeon-cat');
  if (!wrap || !bubble || !pigeon || !cat) return;

  const DEFAULT_MSG = 'envoyer un pigeon voyageur';
  // EXACTEMENT 2 lignes :
  const BLOCK_MSG   = 'décollage impossible : le chat est là !\nUtilisez plutôt le bouton ci-dessous. merci';

  const DISPLAY_MS  = 3500;  // durée d'affichage du message 2 lignes (+2s vs avant)
  const FADE_MS     = 350;   // doit correspondre au CSS

  let locked = false;
  let timer  = null;

  // --- Patch FF: premier survol parfois “mou” → on force un reflow safe au 1er hover
  let primed = false;
  const primeHover = () => {
    if (primed) return;
    // retire toute trace d’un éventuel état résiduel + force reflow
    bubble.classList.remove('bubble--fade');
    // lecture synchrone pour forcer le navigateur à prendre en compte l’état
    void bubble.offsetWidth;
    primed = true;
  };

  // Chat apparaît au hover (si pas lock)
  wrap.addEventListener('mouseenter', () => {
    primeHover();
    if (locked) return;
    cat.classList.add('cat--in');
    cat.classList.remove('cat--out');
  });
  wrap.addEventListener('mouseleave', () => {
    if (locked) return;
    cat.classList.remove('cat--in');
    cat.classList.add('cat--out');
  });

  // Clic → message 2 lignes + fade out sans glitch
  wrap.addEventListener('click', () => {
    if (locked) return;
    locked = true;

    wrap.classList.add('msg-lock');
    bubble.classList.remove('bubble--fade'); // reset au cas où
    bubble.textContent = BLOCK_MSG;

    cat.classList.add('cat--in');
    cat.classList.remove('cat--out');

    clearTimeout(timer);
    timer = setTimeout(() => {
      // Lancer le fade d'abord (on ne change PAS le texte ici)
      bubble.classList.add('bubble--fade');

      // Fin de transition → reset propre sans flash
      const onFadeEnd = (e) => {
        if (e.propertyName !== 'opacity') return;
        bubble.removeEventListener('transitionend', onFadeEnd);

        // on sort du mode lock APRES avoir gagné la spécificité via .bubble--fade
        wrap.classList.remove('msg-lock');
        bubble.classList.remove('bubble--fade');
        bubble.style.opacity = '0';           // s'assure que c'est bien caché
        bubble.textContent = DEFAULT_MSG;     // on remet le texte maintenant

        cat.classList.remove('cat--in');
        cat.classList.add('cat--out');

        locked = false;
      };
      bubble.addEventListener('transitionend', onFadeEnd);
    }, DISPLAY_MS);
  });

  // position verticale du chat
  function positionCatY(){
    const r = pigeon.getBoundingClientRect();
    cat.style.top = Math.round(r.top + r.height + 30) + 'px';
  }
  window.addEventListener('resize', positionCatY);
  window.addEventListener('scroll', positionCatY, { passive:true });

  // si l'image n'est pas encore décodée, cale après
  if ('decode' in pigeon) {
    pigeon.decode().finally(positionCatY);
  } else {
    positionCatY();
  }
})();
</script>
